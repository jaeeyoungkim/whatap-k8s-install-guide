// Enhanced generator for WhaTap Kubernetes installation files and commands
// This provides more comprehensive and accurate configurations than the original

export function generateInstallationFiles(config) {
  const {
    accessKey,
    whatapServer,
    whatapPort,
    imageVersion,
    installMethod,
    k8sVersion,
    containerRuntime,
    isGke,
    isOpenShift,
    isIstio,
    isGpu,
    useApm,
    useOpenMetrics,
    // APM Target Configuration - Multiple targets
    apmTargets,
    // OpenMetrics Target Configuration - Multiple targets
    openMetricsTargets,
  } = config;

  const files = [];
  const timestamp = new Date().toISOString();

  // Common header with configuration summary
  const generateHeader = (method) => `# Generated by WhaTap Kubernetes Installation Guide
# Generated at: ${timestamp}
# Configuration Summary:
#   - Installation Method: ${installMethod}
#   - Image Version: ${imageVersion}
#   - Kubernetes Version: ${k8sVersion}
#   - Container Runtime: ${containerRuntime}
#   - Platform: ${isGke ? 'GKE ' : ''}${isOpenShift ? 'OpenShift ' : ''}${isIstio ? 'Istio ' : ''}${isGpu ? 'GPU ' : ''}
#   - Features: ${useApm ? 'APM ' : ''}${useOpenMetrics ? 'OpenMetrics ' : ''}
# ================================================================

`;

  if (installMethod === 'operator') {
    // Only generate the WhatapAgent Custom Resource file
    // Namespace and secret are now created via direct kubectl commands
    let crSpec = `apiVersion: monitoring.whatap.com/v2alpha1
kind: WhatapAgent
metadata:
  name: whatap
  namespace: whatap-monitoring
  labels:
    app.kubernetes.io/name: whatap
    app.kubernetes.io/managed-by: whatap-operator
spec:
  features:
    k8sAgent:
      customAgentImageFullName: "${imageVersion === 'stable' ? 'public.ecr.aws/whatap/kube_mon:1.8.5' : 'public.ecr.aws/whatap/kube_mon:latest'}"
      masterAgent:
        enabled: true
      nodeAgent:
        enabled: true`;

    // Add container runtime specific configuration
    if (containerRuntime !== 'containerd') {
      crSpec += `
      containerRuntime: "${containerRuntime}"`;
    }

    // Add platform-specific configurations
    if (isGke) {
      crSpec += `
      gke:
        enabled: true`;
    }

    if (isOpenShift) {
      crSpec += `
      openshift:
        enabled: true
        securityContextConstraints: true`;
    }

    if (isIstio) {
      crSpec += `
      istio:
        enabled: true
        sidecarInjection: true`;
    }

    if (isGpu) {
      crSpec += `

  # GPU monitoring
  gpuMonitoring:
    enabled: true`;
    }

    if (useApm && apmTargets && apmTargets.length > 0) {
      // Get APM version based on language (only supported languages)
      const getApmVersion = (language) => {
        const versions = {
          java: "2.2.58",
          nodejs: "2.2.58",
          python: "2.2.58"
        };
        return versions[language] || "2.2.58";
      };

      crSpec += `
    apm:
      instrumentation:
        targets:`;

      // Generate configuration for each target
      apmTargets.forEach((target, index) => {
        crSpec += `
          - name: ${target.name || `app-${index + 1}`}
            enabled: true
            language: "${target.language || 'java'}"
            whatapApmVersions:
              ${target.language || 'java'}: "${getApmVersion(target.language)}"
            namespaceSelector:`;

        // Handle namespace selection based on method
        if (target.namespaceSelectionMethod === 'label' && target.namespaceLabels && target.namespaceLabels.length > 0) {
          // Use matchLabels for label-based selection
          const validLabels = target.namespaceLabels.filter(label => label.key && label.key.trim() && label.value && label.value.trim());
          if (validLabels.length > 0) {
            crSpec += `
              matchLabels:`;
            validLabels.forEach(label => {
              crSpec += `
                ${label.key}: "${label.value}"`;
            });
          } else {
            // Fallback to name-based selection if no valid labels
            const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
            crSpec += `
              matchNames:`;
            namespaceList.forEach(namespace => {
              crSpec += `
                - ${namespace}`;
            });
          }
        } else {
          // Use matchNames for name-based selection (default)
          const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
          crSpec += `
              matchNames:`;

          // Add namespace list for this target
          namespaceList.forEach(namespace => {
            crSpec += `
                - ${namespace}`;
          });
        }

        crSpec += `
            podSelector:
              matchLabels:`;
        
        // Handle pod labels - use array if available, fallback to default
        if (target.podLabels && target.podLabels.length > 0) {
          const validPodLabels = target.podLabels.filter(label => label.key && label.key.trim() && label.value && label.value.trim());
          if (validPodLabels.length > 0) {
            validPodLabels.forEach(label => {
              crSpec += `
                ${label.key}: "${label.value}"`;
            });
          } else {
            // Fallback to default if no valid labels
            crSpec += `
                app: "${target.name || 'sample-app'}"`;
          }
        } else {
          // Fallback to default if no podLabels array
          crSpec += `
                app: "${target.name || 'sample-app'}"`;
        }
        
        crSpec += `
            config:
              mode: default`;
      });
    }

    if (useOpenMetrics && openMetricsTargets && openMetricsTargets.length > 0) {
      crSpec += `
    openAgent:
      enabled: true
      targets:`;

      // Generate configuration for each OpenMetrics target
      openMetricsTargets.forEach((target, index) => {
        crSpec += `
        - targetName: ${target.targetName || `metrics-${index + 1}`}
          type: ${target.type || 'PodMonitor'}`;

        // Add namespace selector for PodMonitor and ServiceMonitor
        if (target.type === 'PodMonitor' || target.type === 'ServiceMonitor') {
          crSpec += `
          namespaceSelector:`;

          // Handle namespace selection based on method
          if (target.namespaceSelectionMethod === 'label' && target.namespaceLabels && target.namespaceLabels.length > 0) {
            // Use matchLabels for label-based selection
            const validLabels = target.namespaceLabels.filter(label => label.key && label.key.trim() && label.value && label.value.trim());
            if (validLabels.length > 0) {
              crSpec += `
            matchLabels:`;
              validLabels.forEach(label => {
                crSpec += `
              ${label.key}: "${label.value}"`;
              });
            } else {
              // Fallback to name-based selection if no valid labels
              const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
              crSpec += `
            matchNames:`;
              namespaceList.forEach(namespace => {
                crSpec += `
              - "${namespace}"`;
              });
            }
          } else {
            // Use matchNames for name-based selection (default)
            const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
            crSpec += `
            matchNames:`;

            // Add namespace list for this target
            namespaceList.forEach(namespace => {
              crSpec += `
              - "${namespace}"`;
            });
          }

          // Add selector for PodMonitor and ServiceMonitor
          crSpec += `
          selector:
            matchLabels:`;
          
          // Handle selector labels - use array if available, fallback to default
          if (target.selectorLabels && target.selectorLabels.length > 0) {
            const validSelectorLabels = target.selectorLabels.filter(label => label.key && label.key.trim() && label.value && label.value.trim());
            if (validSelectorLabels.length > 0) {
              validSelectorLabels.forEach(label => {
                crSpec += `
              ${label.key}: "${label.value}"`;
              });
            } else {
              // Fallback to default if no valid labels
              crSpec += `
              app: "sample-app"`;
            }
          } else {
            // Fallback to default if no selectorLabels array
            crSpec += `
              app: "sample-app"`;
          }
        }

        // Add endpoints configuration
        crSpec += `
          endpoints:`;

        if (target.type === 'StaticEndpoints') {
          // StaticEndpoints configuration
          crSpec += `
          - address: "${target.address || '192.168.1.100:9100'}"
            scheme: "${target.scheme || 'http'}"
            path: "${target.path || '/metrics'}"
            interval: "${target.interval || '30s'}"`;
        } else {
          // PodMonitor and ServiceMonitor configuration
          crSpec += `
          - port: "${target.port || 'metrics'}"
            path: "${target.path || '/metrics'}"
            interval: "${target.interval || '30s'}"
            scheme: "${target.scheme || 'http'}"`;
        }

        // Add metricRelabelConfigs if they exist and have valid configurations
        if (target.metricRelabelConfigs && target.metricRelabelConfigs.length > 0) {
          const validConfigs = target.metricRelabelConfigs.filter(config => 
            config.sourceLabels && config.sourceLabels.trim() && 
            config.action && config.action.trim()
          );

          if (validConfigs.length > 0) {
            crSpec += `
            metricRelabelConfigs:`;

            validConfigs.forEach(config => {
              crSpec += `
              - source_labels: [${config.sourceLabels}]`;

              if (config.regex && config.regex.trim()) {
                crSpec += `
                regex: "${config.regex}"`;
              }

              crSpec += `
                action: ${config.action}`;

              if (config.action === 'replace') {
                if (config.targetLabel && config.targetLabel.trim()) {
                  crSpec += `
                target_label: ${config.targetLabel}`;
                }
                if (config.replacement && config.replacement.trim()) {
                  crSpec += `
                replacement: "${config.replacement}"`;
                }
              }
            });
          }
        }
      });
    }

    files.push({
      name: 'whatap-agent-cr.yaml',
      language: 'yaml',
      method: 'Operator',
      content: generateHeader('Operator') + crSpec
    });
  }

  if (installMethod === 'helm') {
    let valuesContent = `# WhaTap Agent Helm Values
# Generated configuration for direct Helm installation

# License and server configuration
license: "${accessKey}"
whatapHost: "${whatapServer}"
whatapPort: "${whatapPort}"

# Namespace configuration
namespace:
  create: true
  name: whatap-monitoring

# Image configuration
image:
  repository: whatap/kube_mon
  tag: "${imageVersion}"
  pullPolicy: IfNotPresent

# Resource configuration
resources:
  limits:
    cpu: 200m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 256Mi

# Node selector and tolerations
nodeSelector: {}
tolerations: []
affinity: {}`;

    // Add platform-specific configurations
    if (isGke) {
      valuesContent += `

# GKE specific configuration
gke:
  enabled: true
  autopilot: false  # Set to true if using GKE Autopilot`;
    }

    if (isOpenShift) {
      valuesContent += `

# OpenShift specific configuration
openshift:
  enabled: true
  securityContextConstraints:
    create: true`;
    }

    if (isGpu) {
      valuesContent += `

# GPU monitoring configuration
gpu:
  enabled: true
  nodeSelector:
    accelerator: nvidia-tesla-k80  # Adjust based on your GPU type`;
    }

    if (containerRuntime !== 'containerd') {
      valuesContent += `

# Container runtime configuration
containerRuntime: "${containerRuntime}"`;
    }

    files.push({
      name: 'values.yaml',
      language: 'yaml',
      method: 'Helm',
      content: generateHeader('Helm') + valuesContent
    });
  }

  if (installMethod === 'yaml') {
    // Generate whatap-open-agent standalone YAML
    let standaloneContent = `# WhaTap Open Agent - Standalone Installation
# This file contains all necessary resources for manual installation

---
apiVersion: v1
kind: Namespace
metadata:
  name: whatap-monitoring
  labels:
    name: whatap-monitoring

---
apiVersion: v1
kind: Secret
metadata:
  name: whatap-credentials
  namespace: whatap-monitoring
type: Opaque
stringData:
  WHATAP_LICENSE: "${accessKey}"
  WHATAP_HOST: "${whatapServer}"
  WHATAP_PORT: "${whatapPort}"

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: whatap-open-agent-sa
  namespace: whatap-monitoring

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: whatap-open-agent-role
rules:
- apiGroups: ["*"]
  resources: ["pods", "services", "endpoints", "namespaces"]
  verbs: ["get", "list", "watch"]
- nonResourceURLs: [ "/metrics" ]
  verbs: ["*"]
- apiGroups:
  - ""
  resources:
  - "pods/exec"
  verbs:
  - "create"
- apiGroups:
  - ""
  resources:
  - "configmaps"
  verbs:
  - "*"
- nonResourceURLs:
  - "/metrics"
  verbs:
  - "*"

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: whatap-open-agent-role-binding
subjects:
- kind: ServiceAccount
  name: whatap-open-agent-sa
  namespace: whatap-monitoring
roleRef:
  kind: ClusterRole
  name: whatap-open-agent-role
  apiGroup: rbac.authorization.k8s.io

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: whatap-open-agent
  namespace: whatap-monitoring
  labels:
    app: whatap-open-agent
spec:
  replicas: 1
  selector:
    matchLabels:
      app: whatap-open-agent
  template:
    metadata:
      labels:
        app: whatap-open-agent
    spec:
      serviceAccountName: whatap-open-agent-sa
      containers:
      - name: whatap-open-agent
        image: public.ecr.aws/whatap/open_agent:latest
        imagePullPolicy: Always
        env:
        - name: WHATAP_LICENSE
          valueFrom:
            secretKeyRef:
              name: whatap-credentials
              key: WHATAP_LICENSE
        - name: WHATAP_HOST
          valueFrom:
            secretKeyRef:
              name: whatap-credentials
              key: WHATAP_HOST
        - name: WHATAP_PORT
          valueFrom:
            secretKeyRef:
              name: whatap-credentials
              key: WHATAP_PORT
        volumeMounts:
        - name: config-volume
          mountPath: /app/scrape_config.yaml
          subPath: scrape_config.yaml
        - name: logs-volume
          mountPath: /app/logs
      volumes:
      - name: config-volume
        configMap:
          name: whatap-open-agent-config
      - name: logs-volume
        emptyDir: {}

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: whatap-open-agent-config
  namespace: whatap-monitoring
data:
  scrape_config.yaml: |
    #configuration
    #CR format configuration
    features:
      openAgent:
        enabled: true
        targets:`;

    // Generate OpenMetrics targets configuration
    if (useOpenMetrics && openMetricsTargets && openMetricsTargets.length > 0) {
      openMetricsTargets.forEach((target, index) => {
        const enabled = target.enabled !== undefined ? target.enabled : true;
        standaloneContent += `
          - targetName: ${target.targetName || `target-${index + 1}`}
            enabled: ${enabled}
            type: ${target.type || 'PodMonitor'}`;

        // Add namespace selector for PodMonitor and ServiceMonitor
        if (target.type === 'PodMonitor' || target.type === 'ServiceMonitor') {
          standaloneContent += `
            namespaceSelector:`;

          // Handle namespace selection based on method
          if (target.namespaceSelectionMethod === 'label' && target.namespaceLabels && target.namespaceLabels.length > 0) {
            const validLabels = target.namespaceLabels.filter(label => label.key && label.key.trim() && label.value && label.value.trim());
            if (validLabels.length > 0) {
              standaloneContent += `
              matchLabels:`;
              validLabels.forEach(label => {
                standaloneContent += `
                ${label.key}: "${label.value}"`;
              });
            } else {
              // Fallback to name-based selection if no valid labels
              const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
              standaloneContent += `
              matchNames:`;
              namespaceList.forEach(namespace => {
                standaloneContent += `
                - "${namespace}"`;
              });
            }
          } else {
            const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
            standaloneContent += `
              matchNames:`;
            namespaceList.forEach(namespace => {
              standaloneContent += `
                - "${namespace}"`;
            });
          }

          // Add selector for PodMonitor and ServiceMonitor
          standaloneContent += `
            selector:
              matchLabels:`;
          
          // Handle selector labels - use array if available, fallback to default
          if (target.selectorLabels && target.selectorLabels.length > 0) {
            const validSelectorLabels = target.selectorLabels.filter(label => label.key && label.key.trim() && label.value && label.value.trim());
            if (validSelectorLabels.length > 0) {
              validSelectorLabels.forEach(label => {
                standaloneContent += `
                ${label.key}: "${label.value}"`;
              });
            } else {
              // Fallback to default if no valid labels
              standaloneContent += `
                app: "sample-app"`;
            }
          } else {
            // Fallback to default if no selectorLabels array
            standaloneContent += `
                app: "sample-app"`;
          }
        }

        // Add endpoints configuration
        standaloneContent += `
            endpoints:`;

        if (target.type === 'StaticEndpoints') {
          standaloneContent += `
            - address: "${target.address || '192.168.1.100:9100'}"
              scheme: "${target.scheme || 'http'}"
              path: "${target.path || '/metrics'}"
              interval: "${target.interval || '30s'}"
              timeout: "${target.timeout || '30s'}"
              addNodeLabel: true`;
        } else {
          standaloneContent += `
            - port: "${target.port || 'metrics'}"
              path: "${target.path || '/metrics'}"
              interval: "${target.interval || '30s'}"
              scheme: "${target.scheme || 'http'}"
              timeout: "${target.timeout || '30s'}"
              addNodeLabel: true`;
        }

        // Add metricRelabelConfigs if they exist
        if (target.metricRelabelConfigs && target.metricRelabelConfigs.length > 0) {
          const validConfigs = target.metricRelabelConfigs.filter(config => 
            config.sourceLabels && config.sourceLabels.trim() && 
            config.action && config.action.trim()
          );

          if (validConfigs.length > 0) {
            standaloneContent += `
              metricRelabelConfigs:`;

            validConfigs.forEach(config => {
              standaloneContent += `
              - target_label: wtp_src
                replacement: "true"
                action: replace
              - source_labels: [${config.sourceLabels}]`;

              if (config.regex && config.regex.trim()) {
                standaloneContent += `
                regex: "${config.regex}"`;
              }

              standaloneContent += `
                action: ${config.action}`;

              if (config.action === 'replace') {
                if (config.targetLabel && config.targetLabel.trim()) {
                  standaloneContent += `
                target_label: ${config.targetLabel}`;
                }
                if (config.replacement && config.replacement.trim()) {
                  standaloneContent += `
                replacement: "${config.replacement}"`;
                }
              }
            });
          }
        } else {
          // Add default metricRelabelConfigs
          standaloneContent += `
              metricRelabelConfigs:
              - target_label: wtp_src
                replacement: "true"
                action: replace`;
        }
      });
    } else {
      // Add default example targets as shown in the issue
      standaloneContent += `
          # Example ServiceMonitor for kube-apiserver
          - targetName: kube-apiserver
            enabled: false
            type: ServiceMonitor
            namespaceSelector:
              matchNames:
                - "default"
            selector:
              matchLabels:
                component: apiserver
                provider: kubernetes
            endpoints:
            - port: "metrics"
              path: "/metrics"
              interval: "30s"
              scheme: "http"
              timeout: "30s"
              addNodeLabel: true
              metricRelabelConfigs:
              - target_label: wtp_src
                replacement: "true"
                action: replace
              - source_labels: [__name__]
                regex: "apiserver.*"
                action: keep
          - targetName: dcgm-exporter
            enabled: true
            type: PodMonitor
            namespaceSelector:
              matchNames:
                - "whatap-monitoring"
            selector:
              matchLabels:
                gpu: enabled
                name: whatap-node-agent
            endpoints:
            - port: "9400"
              path: "/metrics"
              interval: "30s"
              scheme: "http"
              timeout: "30s"
              addNodeLabel: true
              metricRelabelConfigs:
              - target_label: wtp_src
                replacement: "true"
                action: replace
              - source_labels: [__name__]
                regex: "DCGM.*"
                action: keep`;
    }

    files.push({
      name: 'whatap-open-agent.yaml',
      language: 'yaml',
      method: 'YAML',
      content: generateHeader('YAML') + standaloneContent
    });
  }

  return files;
}

export function generateCommands(config) {
  const { installMethod, k8sVersion, isOpenShift } = config;
  const commands = [];

  if (installMethod === 'operator') {
    commands.push({
      title: 'Step 1/3: Create Namespace and Credentials',
      method: 'Operator',
      command: `# Create the monitoring namespace
kubectl create ns whatap-monitoring

# Create credentials secret with your project information
kubectl create secret generic whatap-credentials \\
  --namespace whatap-monitoring \\
  --from-literal WHATAP_LICENSE=${config.accessKey} \\
  --from-literal WHATAP_HOST=${config.whatapServer} \\
  --from-literal WHATAP_PORT=${config.whatapPort}

# Verify namespace and secret creation
kubectl get namespace whatap-monitoring
kubectl get secret whatap-credentials -n whatap-monitoring`
    });

    commands.push({
      title: 'Step 2/3: Install WhaTap Operator',
      method: 'Operator',
      command: `# Add WhaTap Helm repository
helm repo add whatap https://whatap.github.io/helm/
helm repo update

# Install the WhaTap Operator
helm install whatap-operator whatap/whatap-operator --namespace whatap-monitoring

# Verify operator installation
kubectl get pods -n whatap-monitoring -l app.kubernetes.io/name=whatap-operator`
    });

    commands.push({
      title: 'Step 3/3: Deploy WhaTap Agent',
      method: 'Operator',
      command: `# Apply the WhatapAgent custom resource
kubectl apply -f whatap-agent-cr.yaml

# Verify agent deployment
kubectl get whatapagent -n whatap-monitoring
kubectl get pods -n whatap-monitoring -l app.kubernetes.io/name=whatap-agent

# Check agent logs
kubectl logs -n whatap-monitoring -l app.kubernetes.io/name=whatap-agent --tail=50`
    });
  }

  if (installMethod === 'helm') {
    commands.push({
      title: 'Step 1/3: Add WhaTap Helm Repository',
      method: 'Helm',
      command: `# Add WhaTap Helm repository
helm repo add whatap https://whatap.github.io/helm/
helm repo update

# Verify repository addition
helm search repo whatap`
    });

    commands.push({
      title: 'Step 2/3: Install WhaTap Agent with Custom Values',
      method: 'Helm',
      command: `# Install WhaTap agent using custom values
helm install whatap-agent whatap/whatap-agent \\
  --namespace whatap-monitoring \\
  --create-namespace \\
  --values values.yaml

# Alternative: Install with inline values
# helm install whatap-agent whatap/whatap-agent \\
#   --namespace whatap-monitoring \\
#   --create-namespace \\
#   --set license="${config.accessKey}" \\
#   --set whatapHost="${config.whatapServer}"`
    });

    commands.push({
      title: 'Step 3/3: Verify Installation',
      method: 'Helm',
      command: `# Check Helm release status
helm status whatap-agent -n whatap-monitoring

# Verify pods are running
kubectl get pods -n whatap-monitoring

# Check agent logs
kubectl logs -n whatap-monitoring -l app.kubernetes.io/name=whatap-agent --tail=50

# Check service status
kubectl get svc -n whatap-monitoring`
    });
  }

  if (installMethod === 'yaml') {
    let applyCommand = `# Apply the whatap-open-agent YAML configuration
kubectl apply -f whatap-open-agent.yaml`;

    if (isOpenShift) {
      applyCommand = `# For OpenShift, you may need to create security context constraints first
# oc adm policy add-scc-to-user privileged -z whatap-open-agent-sa -n whatap-monitoring

# Apply the whatap-open-agent YAML configuration
kubectl apply -f whatap-open-agent.yaml`;
    }

    commands.push({
      title: 'Step 1/2: Apply Configuration',
      method: 'YAML',
      command: applyCommand
    });

    commands.push({
      title: 'Step 2/2: Verify Installation',
      method: 'YAML',
      command: `# Check if all resources are created
kubectl get all -n whatap-monitoring

# Verify Deployment is running
kubectl get deployment whatap-open-agent -n whatap-monitoring

# Check open agent logs
kubectl logs -n whatap-monitoring -l app=whatap-open-agent --tail=50

# Verify ConfigMap is created
kubectl get configmap whatap-open-agent-config -n whatap-monitoring

# Check the scrape configuration
kubectl get configmap whatap-open-agent-config -n whatap-monitoring -o yaml`
    });
  }

  // Add common verification steps
  commands.push({
    title: 'Final Verification',
    method: 'All Methods',
    command: `# Check overall monitoring status
kubectl get pods -n whatap-monitoring`
  });
  return commands;
}
