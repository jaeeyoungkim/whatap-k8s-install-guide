// Enhanced generator for WhaTap Kubernetes installation files and commands
// This provides more comprehensive and accurate configurations than the original

export function generateInstallationFiles(config) {
  const {
    accessKey,
    whatapServer,
    whatapPort,
    imageVersion,
    installMethod,
    k8sVersion,
    containerRuntime,
    isGke,
    isOpenShift,
    isIstio,
    isGpu,
    useApm,
    useOpenMetrics,
    // APM Target Configuration - Multiple targets
    apmTargets,
    // OpenMetrics Target Configuration - Multiple targets
    openMetricsTargets,
  } = config;

  const files = [];
  const timestamp = new Date().toISOString();

  // Common header with configuration summary
  const generateHeader = (method) => `# Generated by WhaTap Kubernetes Installation Guide
# Generated at: ${timestamp}
# Configuration Summary:
#   - Installation Method: ${installMethod}
#   - Image Version: ${imageVersion}
#   - Kubernetes Version: ${k8sVersion}
#   - Container Runtime: ${containerRuntime}
#   - Platform: ${isGke ? 'GKE ' : ''}${isOpenShift ? 'OpenShift ' : ''}${isIstio ? 'Istio ' : ''}${isGpu ? 'GPU ' : ''}
#   - Features: ${useApm ? 'APM ' : ''}${useOpenMetrics ? 'OpenMetrics ' : ''}
# ================================================================

`;

  if (installMethod === 'operator') {
    // Only generate the WhatapAgent Custom Resource file
    // Namespace and secret are now created via direct kubectl commands
    let crSpec = `apiVersion: monitoring.whatap.com/v2alpha1
kind: WhatapAgent
metadata:
  name: whatap
  namespace: whatap-monitoring
  labels:
    app.kubernetes.io/name: whatap
    app.kubernetes.io/managed-by: whatap-operator
spec:
  agentImageVersion: "${imageVersion}"
  features:
    k8sAgent:
      customAgentImageFullName: "${imageVersion === 'stable' ? 'public.ecr.aws/whatap/kube_mon:1.8.5' : 'public.ecr.aws/whatap/kube_mon:latest'}"
      masterAgent:
        enabled: true
      nodeAgent:
        enabled: true`;

    // Add container runtime specific configuration
    if (containerRuntime !== 'containerd') {
      crSpec += `
      containerRuntime: "${containerRuntime}"`;
    }

    // Add platform-specific configurations
    if (isGke) {
      crSpec += `
      gke:
        enabled: true`;
    }

    if (isOpenShift) {
      crSpec += `
      openshift:
        enabled: true
        securityContextConstraints: true`;
    }

    if (isIstio) {
      crSpec += `
      istio:
        enabled: true
        sidecarInjection: true`;
    }

    if (isGpu) {
      crSpec += `

  # GPU monitoring
  gpuMonitoring:
    enabled: true
    nodeSelector:
      accelerator: nvidia-tesla-k80  # Adjust based on your GPU type`;
    }

    if (useApm && apmTargets && apmTargets.length > 0) {
      // Get APM version based on language (only supported languages)
      const getApmVersion = (language) => {
        const versions = {
          java: "2.2.58",
          nodejs: "2.2.58",
          python: "2.2.58"
        };
        return versions[language] || "2.2.58";
      };

      crSpec += `
    apm:
      instrumentation:
        targets:`;

      // Generate configuration for each target
      apmTargets.forEach((target, index) => {
        crSpec += `
          - name: ${target.name || `app-${index + 1}`}
            enabled: true
            language: "${target.language || 'java'}"
            whatapApmVersions:
              ${target.language || 'java'}: "${getApmVersion(target.language)}"
            namespaceSelector:`;

        // Handle namespace selection based on method
        if (target.namespaceSelectionMethod === 'label' && target.namespaceLabelKey && target.namespaceLabelValue) {
          // Use matchLabels for label-based selection
          crSpec += `
              matchLabels:
                ${target.namespaceLabelKey}: "${target.namespaceLabelValue}"`;
        } else {
          // Use matchNames for name-based selection (default)
          const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
          crSpec += `
              matchNames:`;

          // Add namespace list for this target
          namespaceList.forEach(namespace => {
            crSpec += `
                - ${namespace}`;
          });
        }

        crSpec += `
            podSelector:
              matchLabels:
                ${target.podLabelKey || 'app'}: "${target.podLabelValue || target.name || 'sample-app'}"
            config:
              mode: default`;
      });
    }

    if (useOpenMetrics && openMetricsTargets && openMetricsTargets.length > 0) {
      crSpec += `
    openAgent:
      enabled: true
      targets:`;

      // Generate configuration for each OpenMetrics target
      openMetricsTargets.forEach((target, index) => {
        crSpec += `
        - targetName: ${target.targetName || `metrics-${index + 1}`}
          type: ${target.type || 'PodMonitor'}`;

        // Add namespace selector for PodMonitor and ServiceMonitor
        if (target.type === 'PodMonitor' || target.type === 'ServiceMonitor') {
          crSpec += `
          namespaceSelector:`;

          // Handle namespace selection based on method
          if (target.namespaceSelectionMethod === 'label' && target.namespaceLabelKey && target.namespaceLabelValue) {
            // Use matchLabels for label-based selection
            crSpec += `
            matchLabels:
              ${target.namespaceLabelKey}: "${target.namespaceLabelValue}"`;
          } else {
            // Use matchNames for name-based selection (default)
            const namespaceList = target.namespaces ? target.namespaces.split(',').map(ns => ns.trim()).filter(ns => ns) : ['default'];
            crSpec += `
            matchNames:`;

            // Add namespace list for this target
            namespaceList.forEach(namespace => {
              crSpec += `
              - "${namespace}"`;
            });
          }

          // Add selector for PodMonitor and ServiceMonitor
          crSpec += `
          selector:
            matchLabels:
              ${target.selectorLabelKey || 'app'}: "${target.selectorLabelValue || 'sample-app'}"`;
        }

        // Add endpoints configuration
        crSpec += `
          endpoints:`;

        if (target.type === 'StaticEndpoints') {
          // StaticEndpoints configuration
          crSpec += `
          - address: "${target.address || '192.168.1.100:9100'}"
            scheme: "${target.scheme || 'http'}"
            path: "${target.path || '/metrics'}"
            interval: "${target.interval || '30s'}"`;
        } else {
          // PodMonitor and ServiceMonitor configuration
          crSpec += `
          - port: "${target.port || 'metrics'}"
            path: "${target.path || '/metrics'}"
            interval: "${target.interval || '30s'}"
            scheme: "${target.scheme || 'http'}"`;
        }

        // Add metricRelabelConfigs if they exist and have valid configurations
        if (target.metricRelabelConfigs && target.metricRelabelConfigs.length > 0) {
          const validConfigs = target.metricRelabelConfigs.filter(config => 
            config.sourceLabels && config.sourceLabels.trim() && 
            config.action && config.action.trim()
          );

          if (validConfigs.length > 0) {
            crSpec += `
            metricRelabelConfigs:`;

            validConfigs.forEach(config => {
              crSpec += `
              - source_labels: [${config.sourceLabels}]`;

              if (config.regex && config.regex.trim()) {
                crSpec += `
                regex: "${config.regex}"`;
              }

              crSpec += `
                action: ${config.action}`;

              if (config.action === 'replace') {
                if (config.targetLabel && config.targetLabel.trim()) {
                  crSpec += `
                target_label: ${config.targetLabel}`;
                }
                if (config.replacement && config.replacement.trim()) {
                  crSpec += `
                replacement: "${config.replacement}"`;
                }
              }
            });
          }
        }
      });
    }

    files.push({
      name: 'whatap-agent-cr.yaml',
      language: 'yaml',
      method: 'Operator',
      content: generateHeader('Operator') + crSpec
    });
  }

  if (installMethod === 'helm') {
    let valuesContent = `# WhaTap Agent Helm Values
# Generated configuration for direct Helm installation

# License and server configuration
license: "${accessKey}"
whatapHost: "${whatapServer}"
whatapPort: "${whatapPort}"

# Namespace configuration
namespace:
  create: true
  name: whatap-monitoring

# Image configuration
image:
  repository: whatap/kube_mon
  tag: "${imageVersion}"
  pullPolicy: IfNotPresent

# Resource configuration
resources:
  limits:
    cpu: 200m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 256Mi

# Node selector and tolerations
nodeSelector: {}
tolerations: []
affinity: {}`;

    // Add platform-specific configurations
    if (isGke) {
      valuesContent += `

# GKE specific configuration
gke:
  enabled: true
  autopilot: false  # Set to true if using GKE Autopilot`;
    }

    if (isOpenShift) {
      valuesContent += `

# OpenShift specific configuration
openshift:
  enabled: true
  securityContextConstraints:
    create: true`;
    }

    if (isGpu) {
      valuesContent += `

# GPU monitoring configuration
gpu:
  enabled: true
  nodeSelector:
    accelerator: nvidia-tesla-k80  # Adjust based on your GPU type`;
    }

    if (containerRuntime !== 'containerd') {
      valuesContent += `

# Container runtime configuration
containerRuntime: "${containerRuntime}"`;
    }

    files.push({
      name: 'values.yaml',
      language: 'yaml',
      method: 'Helm',
      content: generateHeader('Helm') + valuesContent
    });
  }

  if (installMethod === 'yaml') {
    // Generate comprehensive standalone YAML
    let standaloneContent = `# WhaTap Kubernetes Agent - Standalone Installation
# This file contains all necessary resources for manual installation

---
apiVersion: v1
kind: Namespace
metadata:
  name: whatap-monitoring
  labels:
    name: whatap-monitoring

---
apiVersion: v1
kind: Secret
metadata:
  name: whatap-credentials
  namespace: whatap-monitoring
type: Opaque
stringData:
  WHATAP_LICENSE: "${accessKey}"
  WHATAP_HOST: "${whatapServer}"
  WHATAP_PORT: "${whatapPort}"

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: whatap-agent
  namespace: whatap-monitoring

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: whatap-agent
rules:
- apiGroups: [""]
  resources: ["nodes", "nodes/metrics", "services", "endpoints", "pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets", "daemonsets", "statefulsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["batch"]
  resources: ["jobs", "cronjobs"]
  verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: whatap-agent
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: whatap-agent
subjects:
- kind: ServiceAccount
  name: whatap-agent
  namespace: whatap-monitoring

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: whatap-node-agent
  namespace: whatap-monitoring
  labels:
    app: whatap-node-agent
spec:
  selector:
    matchLabels:
      app: whatap-node-agent
  template:
    metadata:
      labels:
        app: whatap-node-agent
    spec:
      serviceAccountName: whatap-agent
      hostNetwork: true
      hostPID: true
      containers:
      - name: whatap-node-agent
        image: "whatap/kube_mon:${imageVersion}"
        env:
        - name: WHATAP_LICENSE
          valueFrom:
            secretKeyRef:
              name: whatap-credentials
              key: WHATAP_LICENSE
        - name: WHATAP_HOST
          valueFrom:
            secretKeyRef:
              name: whatap-credentials
              key: WHATAP_HOST
        - name: WHATAP_PORT
          valueFrom:
            secretKeyRef:
              name: whatap-credentials
              key: WHATAP_PORT
        - name: NODE_IP
          valueFrom:
            fieldRef:
              fieldPath: status.hostIP
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        resources:
          limits:
            cpu: 200m
            memory: 512Mi
          requests:
            cpu: 100m
            memory: 256Mi
        volumeMounts:
        - name: proc
          mountPath: /host/proc
          readOnly: true
        - name: sys
          mountPath: /host/sys
          readOnly: true`;

    // Add container runtime specific volume mounts
    if (containerRuntime === 'docker') {
      standaloneContent += `
        - name: docker-sock
          mountPath: /var/run/docker.sock
          readOnly: true`;
    } else if (containerRuntime === 'containerd') {
      standaloneContent += `
        - name: containerd-sock
          mountPath: /var/run/containerd/containerd.sock
          readOnly: true`;
    }

    standaloneContent += `
      volumes:
      - name: proc
        hostPath:
          path: /proc
      - name: sys
        hostPath:
          path: /sys`;

    // Add runtime-specific volumes
    if (containerRuntime === 'docker') {
      standaloneContent += `
      - name: docker-sock
        hostPath:
          path: /var/run/docker.sock`;
    } else if (containerRuntime === 'containerd') {
      standaloneContent += `
      - name: containerd-sock
        hostPath:
          path: /var/run/containerd/containerd.sock`;
    }

    // Add platform-specific configurations
    if (isOpenShift) {
      standaloneContent += `
      securityContext:
        runAsUser: 0
        privileged: true`;
    }

    if (isGpu) {
      standaloneContent += `
      nodeSelector:
        accelerator: nvidia-tesla-k80  # Adjust based on your GPU type`;
    }

    files.push({
      name: 'whatap-standalone.yaml',
      language: 'yaml',
      method: 'YAML',
      content: generateHeader('YAML') + standaloneContent
    });
  }

  return files;
}

export function generateCommands(config) {
  const { installMethod, k8sVersion, isOpenShift } = config;
  const commands = [];

  if (installMethod === 'operator') {
    commands.push({
      title: 'Step 1/3: Create Namespace and Credentials',
      method: 'Operator',
      command: `# Create the monitoring namespace
kubectl create ns whatap-monitoring

# Create credentials secret with your project information
kubectl create secret generic whatap-credentials \\
  --namespace whatap-monitoring \\
  --from-literal WHATAP_LICENSE=${config.accessKey} \\
  --from-literal WHATAP_HOST=${config.whatapServer} \\
  --from-literal WHATAP_PORT=${config.whatapPort}

# Verify namespace and secret creation
kubectl get namespace whatap-monitoring
kubectl get secret whatap-credentials -n whatap-monitoring`
    });

    commands.push({
      title: 'Step 2/3: Install WhaTap Operator',
      method: 'Operator',
      command: `# Add WhaTap Helm repository
helm repo add whatap https://whatap.github.io/helm/
helm repo update

# Install the WhaTap Operator
helm install whatap-operator whatap/whatap-operator --namespace whatap-monitoring

# Verify operator installation
kubectl get pods -n whatap-monitoring -l app.kubernetes.io/name=whatap-operator`
    });

    commands.push({
      title: 'Step 3/3: Deploy WhaTap Agent',
      method: 'Operator',
      command: `# Apply the WhatapAgent custom resource
kubectl apply -f whatap-agent-cr.yaml

# Verify agent deployment
kubectl get whatapagent -n whatap-monitoring
kubectl get pods -n whatap-monitoring -l app.kubernetes.io/name=whatap-agent

# Check agent logs
kubectl logs -n whatap-monitoring -l app.kubernetes.io/name=whatap-agent --tail=50`
    });
  }

  if (installMethod === 'helm') {
    commands.push({
      title: 'Step 1/3: Add WhaTap Helm Repository',
      method: 'Helm',
      command: `# Add WhaTap Helm repository
helm repo add whatap https://whatap.github.io/helm/
helm repo update

# Verify repository addition
helm search repo whatap`
    });

    commands.push({
      title: 'Step 2/3: Install WhaTap Agent with Custom Values',
      method: 'Helm',
      command: `# Install WhaTap agent using custom values
helm install whatap-agent whatap/whatap-agent \\
  --namespace whatap-monitoring \\
  --create-namespace \\
  --values values.yaml

# Alternative: Install with inline values
# helm install whatap-agent whatap/whatap-agent \\
#   --namespace whatap-monitoring \\
#   --create-namespace \\
#   --set license="${config.accessKey}" \\
#   --set whatapHost="${config.whatapServer}"`
    });

    commands.push({
      title: 'Step 3/3: Verify Installation',
      method: 'Helm',
      command: `# Check Helm release status
helm status whatap-agent -n whatap-monitoring

# Verify pods are running
kubectl get pods -n whatap-monitoring

# Check agent logs
kubectl logs -n whatap-monitoring -l app.kubernetes.io/name=whatap-agent --tail=50

# Check service status
kubectl get svc -n whatap-monitoring`
    });
  }

  if (installMethod === 'yaml') {
    let applyCommand = `# Apply the standalone YAML configuration
kubectl apply -f whatap-standalone.yaml`;

    if (isOpenShift) {
      applyCommand = `# For OpenShift, you may need to create security context constraints first
# oc adm policy add-scc-to-user privileged -z whatap-agent -n whatap-monitoring

# Apply the standalone YAML configuration
kubectl apply -f whatap-standalone.yaml`;
    }

    commands.push({
      title: 'Step 1/2: Apply Configuration',
      method: 'YAML',
      command: applyCommand
    });

    commands.push({
      title: 'Step 2/2: Verify Installation',
      method: 'YAML',
      command: `# Check if all resources are created
kubectl get all -n whatap-monitoring

# Verify DaemonSet is running on all nodes
kubectl get daemonset whatap-node-agent -n whatap-monitoring

# Check agent logs
kubectl logs -n whatap-monitoring -l app=whatap-node-agent --tail=50

# Verify agents are running on each node
kubectl get pods -n whatap-monitoring -o wide`
    });
  }

  // Add common verification steps
  commands.push({
    title: 'Final Verification',
    method: 'All Methods',
    command: `# Check overall monitoring status
kubectl get pods -n whatap-monitoring`
  });
  return commands;
}
